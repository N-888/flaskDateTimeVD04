/**
 * script.js - JavaScript файл для приложения FlaskDateTimeVD04
 * Содержит клиентскую логику для динамического обновления времени и взаимодействия с пользователем
 */

// Ждем полной загрузки DOM (Document Object Model) - структуры HTML документа
// Это гарантирует, что все элементы страницы уже созданы и доступны для манипуляций
document.addEventListener('DOMContentLoaded', function() {
    // Вся логика приложения находится внутри этой функции
    // Она выполнится только после того, как браузер полностью загрузит и распарсит HTML

    // ===== ПОЛУЧЕНИЕ ССЫЛОК НА ЭЛЕМЕНТЫ DOM =====

    // Находим элемент с id="currentTime" - это большой дисплей времени
    // getElementById() возвращает первый элемент с указанным id
    const currentTimeElement = document.getElementById('currentTime');

    // Находим кнопку обновления времени по id="refreshBtn"
    const refreshBtn = document.getElementById('refreshBtn');

    // Находим кнопку получения JSON данных по id="apiBtn"
    const apiBtn = document.getElementById('apiBtn');

    // Находим кнопку копирования времени по id="copyBtn"
    const copyBtn = document.getElementById('copyBtn');

    // Находим чекбокс автообновления по id="autoRefresh"
    const autoRefreshCheckbox = document.getElementById('autoRefresh');

    // Находим элемент уведомления по id="notification"
    const notification = document.getElementById('notification');

    // ===== ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ =====

    // Переменная для хранения идентификатора интервала автообновления
    // Используется для контроля и остановки интервала при необходимости
    let autoRefreshInterval;

    // ===== ОСНОВНЫЕ ФУНКЦИИ =====

    /**
     * Функция для обновления времени на странице
     * Выполняет асинхронный запрос к серверному API для получения актуального времени
     * Использует современный Fetch API для работы с HTTP запросами
     */
    function updateTime() {
        // Сохраняем исходный текст времени для возможного восстановления в случае ошибки
        const originalText = currentTimeElement.textContent;

        // Визуальная индикация загрузки - уменьшаем непрозрачность элемента времени
        // 0.5 = 50% непрозрачности (полупрозрачный)
        currentTimeElement.style.opacity = '0.5';

        // Выполняем асинхронный GET запрос к API сервера
        // fetch() возвращает Promise - объект, представляющий результат асинхронной операции
        fetch('/api/current_time')
            // Первый then() обрабатывает объект Response
            .then(response => {
                // Проверяем, успешен ли HTTP ответ (статус 200-299)
                if (!response.ok) {
                    // Если статус не успешен, выбрасываем исключение
                    // Оно будет поймано в блоке catch()
                    throw new Error('Ошибка сети: ' + response.status);
                }
                // Преобразуем ответ из JSON формата в JavaScript объект
                // response.json() также возвращает Promise
                return response.json();
            })
            // Второй then() получает распарсенные данные
            .then(data => {
                // Обновляем текстовое содержимое элемента времени
                // data.time содержит строку времени в формате "HH:MM:SS"
                currentTimeElement.textContent = data.time;

                // Восстанавливаем полную непрозрачность элемента
                currentTimeElement.style.opacity = '1';

                // Показываем уведомление об успешном обновлении
                // 'success' - тип уведомления для зеленого цвета
                showNotification('Время обновлено!', 'success');

                // Дополнительно обновляем другие элементы на странице
                // В данной реализации функция пустая, но может быть расширена
                updateOtherElements(data);
            })
            // catch() обрабатывает любые ошибки, возникшие в цепочке Promise
            .catch(error => {
                // Выводим детальную информацию об ошибке в консоль браузера
                // console.error() подсвечивает вывод красным цветом
                console.error('Ошибка при обновлении времени:', error);

                // Показываем пользователю уведомление об ошибке
                // 'error' - тип уведомления для красного цвета
                showNotification('Ошибка при обновлении времени', 'error');

                // Восстанавливаем исходное значение времени
                currentTimeElement.style.opacity = '1';
                currentTimeElement.textContent = originalText;
            });
    }

    /**
     * Функция для обновления других элементов на странице
     * В текущей реализации не используется, но оставлена для будущего расширения
     * @param {Object} data - Данные о времени, полученные от сервера
     */
    function updateOtherElements(data) {
        // Эту функцию можно использовать для обновления других элементов:
        // - Даты
        // - Дня недели
        // - Часового пояса
        // В данный момент она пустая, так как эти элементы обновляются только
        // при полной перезагрузке страницы или могут быть обновлены здесь
    }

    /**
     * Функция для показа всплывающих уведомлений пользователю
     * Создает временные сообщения в правом нижнем углу экрана
     * @param {string} message - Текст сообщения для отображения
     * @param {string} type - Тип уведомления: 'success', 'error' или 'info'
     */
    function showNotification(message, type = 'info') {
        // Устанавливаем текстовое содержимое элемента уведомления
        notification.textContent = message;

        // Устанавливаем цвет фона в зависимости от типа уведомления
        // Это визуально дифференцирует разные типы сообщений
        if (type === 'success') {
            // Зеленый фон для успешных операций (RGB: 56, 239, 125)
            // 0.9 = 90% непрозрачности
            notification.style.background = 'rgba(56, 239, 125, 0.9)';
            notification.style.color = '#000'; // Черный текст для контраста
        } else if (type === 'error') {
            // Красный фон для ошибок (RGB: 244, 107, 69)
            notification.style.background = 'rgba(244, 107, 69, 0.9)';
            notification.style.color = '#fff'; // Белый текст
        } else {
            // Синий фон для информационных сообщений (RGB: 0, 201, 255)
            notification.style.background = 'rgba(0, 201, 255, 0.9)';
            notification.style.color = '#000'; // Черный текст
        }

        // Добавляем CSS класс 'show' для анимации появления уведомления
        // Класс 'show' определен в CSS и управляет анимацией появления
        notification.classList.add('show');

        // Устанавливаем таймер для автоматического скрытия уведомления
        // setTimeout() выполняет функцию после указанной задержки (3000ms = 3 секунды)
        setTimeout(() => {
            // Удаляем класс 'show', что запускает анимацию скрытия
            notification.classList.remove('show');
        }, 3000);
    }

    /**
     * Функция для копирования текущего времени и даты в буфер обмена
     * Использует современный Clipboard API для безопасного доступа к буферу обмена
     */
    function copyTimeToClipboard() {
        // Получаем текущее время из элемента на странице
        const timeText = currentTimeElement.textContent;

        // Получаем текущую дату из элемента с классом 'date-large'
        // querySelector() возвращает первый элемент, соответствующий CSS селектору
        const dateText = document.querySelector('.date-large').textContent;

        // Формируем полный текст для копирования
        const fullText = `FlaskDateTimeVD04 - Текущее время: ${timeText}, дата: ${dateText}`;

        // Используем асинхронный Clipboard API для записи текста в буфер обмена
        // navigator.clipboard предоставляет доступ к системному буферу обмена
        navigator.clipboard.writeText(fullText)
            .then(() => {
                // Успешное копирование
                showNotification('Время скопировано в буфер обмена!', 'success');
            })
            .catch(err => {
                // Обработка ошибок копирования
                // Может возникнуть если браузер не поддерживает API или пользователь не дал разрешение
                console.error('Ошибка при копировании: ', err);
                showNotification('Не удалось скопировать время', 'error');
            });
    }

    /**
     * Функция для получения и отображения сырых JSON данных от API
     * Показывает полную структуру данных, возвращаемых сервером
     */
    function fetchApiData() {
        // Выполняем запрос к API
        fetch('/api/current_time')
            // Преобразуем ответ в JSON
            .then(response => response.json())
            .then(data => {
                // Форматируем JSON данные для красивого отображения
                // JSON.stringify() преобразует объект в строку JSON
                // Параметры: null (фильтр), 2 (отступ в пробелах)
                const formattedData = JSON.stringify(data, null, 2);

                // Показываем данные в стандартном диалоговом окне alert
                // В реальном приложении лучше использовать модальное окно
                alert('Данные от API FlaskDateTimeVD04:\n\n' + formattedData);

                // Показываем уведомление об успешном получении данных
                showNotification('Данные от API получены!', 'success');
            })
            .catch(error => {
                // Обработка ошибок при запросе к API
                console.error('Ошибка при получении данных от API:', error);
                showNotification('Ошибка при получении данных от API', 'error');
            });
    }

    /**
     * Функция для включения/выключения автоматического обновления времени
     * Управляет интервальным обновлением данных с сервера
     */
    function toggleAutoRefresh() {
        // Проверяем состояние чекбокса автообновления
        if (autoRefreshCheckbox.checked) {
            // Если чекбокс отмечен, запускаем автообновление

            // setInterval() выполняет функцию updateTime каждые 1000ms (1 секунда)
            // Возвращает ID интервала, который можно использовать для его остановки
            autoRefreshInterval = setInterval(updateTime, 1000);

            // Информируем пользователя
            showNotification('Автообновление включено', 'info');
        } else {
            // Если чекбокс не отмечен, останавливаем автообновление

            // clearInterval() останавливает интервал по его ID
            clearInterval(autoRefreshInterval);

            // Информируем пользователя
            showNotification('Автообновление отключено', 'info');
        }
    }

    /**
     * Функция для анимации нажатия кнопки
     * Создает эффект "нажатия" путем временного уменьшения размера кнопки
     * @param {HTMLElement} button - DOM элемент кнопки для анимации
     */
    function animateButton(button) {
        // Применяем CSS transform для уменьшения кнопки до 95% от исходного размера
        // scale(0.95) уменьшает элемент равномерно по обеим осям
        button.style.transform = 'scale(0.95)';

        // Устанавливаем таймер для восстановления исходного размера
        setTimeout(() => {
            // Убираем transform, возвращая кнопку к исходному размеру
            // Пустая строка удаляет inline стиль, возвращая CSS из файла стилей
            button.style.transform = '';
        }, 150); // 150 миллисекунд - оптимальное время для эффекта нажатия
    }

    // ===== НАЗНАЧЕНИЕ ОБРАБОТЧИКОВ СОБЫТИЙ =====

    // Обработчик события 'click' для кнопки обновления времени
    refreshBtn.addEventListener('click', function() {
        // this внутри обработчика ссылается на элемент, на котором произошло событие (кнопка)

        // Запускаем анимацию нажатия кнопки
        animateButton(this);

        // Выполняем обновление времени
        updateTime();
    });

    // Обработчик события 'click' для кнопки получения JSON данных
    apiBtn.addEventListener('click', function() {
        // Анимируем нажатие кнопки
        animateButton(this);

        // Получаем и показываем данные API
        fetchApiData();
    });

    // Обработчик события 'click' для кнопки копирования времени
    copyBtn.addEventListener('click', function() {
        // Анимируем нажатие кнопки
        animateButton(this);

        // Копируем время в буфер обмена
        copyTimeToClipboard();
    });

    // Обработчик события 'change' для чекбокса автообновления
    // Срабатывает при изменении состояния чекбокса (отмечен/не отмечен)
    autoRefreshCheckbox.addEventListener('change', toggleAutoRefresh);

    // ===== ИНИЦИАЛИЗАЦИЯ ПРИЛОЖЕНИЯ =====

    // При загрузке страницы проверяем состояние чекбокса автообновления
    if (autoRefreshCheckbox.checked) {
        // Если чекбокс изначально отмечен, запускаем автообновление
        autoRefreshInterval = setInterval(updateTime, 1000);
    }

    // ===== ЛОКАЛЬНОЕ ОБНОВЛЕНИЕ СЕКУНД =====

    // Второй интервал для плавного обновления секунд без запросов к серверу
    // Это создает более плавный пользовательский опыт
    setInterval(() => {
        // Получаем текущее время из элемента на странице
        const timeString = currentTimeElement.textContent;

        // Разбиваем строку времени на компоненты по разделителю ':'
        // "14:30:45" -> ["14", "30", "45"]
        const timeParts = timeString.split(':');

        // Парсим компоненты времени в числа
        // parseInt() преобразует строку в целое число
        let hours = parseInt(timeParts[0]);   // Часы (0-23)
        let minutes = parseInt(timeParts[1]); // Минуты (0-59)
        let seconds = parseInt(timeParts[2]); // Секунды (0-59)

        // Увеличиваем секунды на 1
        seconds++;

        // Корректируем время при переполнении секунд
        if (seconds >= 60) {
            // Если секунды достигли 60, обнуляем их и увеличиваем минуты
            seconds = 0;
            minutes++;

            // Корректируем время при переполнении минут
            if (minutes >= 60) {
                // Если минуты достигли 60, обнуляем их и увеличиваем часы
                minutes = 0;
                hours++;

                // Корректируем время при переполнении часов
                if (hours >= 24) {
                    // Если часы достигли 24, обнуляем их (начало новых суток)
                    hours = 0;
                    // При переходе через полночь обновляем время через API
                    // чтобы получить актуальную дату и другие данные
                    updateTime();
                }
            }
        }

        // Форматируем время с ведущими нулями
        // padStart(2, '0') добавляет '0' в начало, если строка короче 2 символов
        const formattedTime =
            hours.toString().padStart(2, '0') + ':' +
            minutes.toString().padStart(2, '0') + ':' +
            seconds.toString().padStart(2, '0');

        // Обновляем отображение времени, только если автообновление включено
        // Это предотвращает конфликты между локальным и серверным обновлением
        if (autoRefreshCheckbox.checked) {
            currentTimeElement.textContent = formattedTime;
        }
    }, 1000); // Интервал 1000ms = 1 секунда

    // ===== ПОКАЗ ПРИВЕТСТВЕННОГО УВЕДОМЛЕНИЯ =====

    // Показываем уведомление о успешной загрузке приложения
    // Задержка 1000ms дает время странице полностью отрисоваться
    setTimeout(() => {
        showNotification('Приложение FlaskDateTimeVD04 загружено! Время обновляется автоматически.', 'success');
    }, 1000);
});

// Конец обработчика DOMContentLoaded
// Весь код выше выполняется только после полной загрузки DOM